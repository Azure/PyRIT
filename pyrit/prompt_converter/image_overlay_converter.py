# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

import base64
from typing import Optional

from PIL import Image
from io import BytesIO
from pathlib import Path

from pyrit.models import data_serializer_factory
from pyrit.models import PromptDataType
from pyrit.prompt_converter import PromptConverter, ConverterResult
from pyrit.memory import MemoryInterface, DuckDBMemory


class ImageOverlayConverter(PromptConverter):
    """
    A converter that takes in a base image, and a secondary image to embed within the main image.

    Args:
        base_image_path (str): File path of the base image
        x_pos (int, optional): X coordinate to place second image on the base image (0 is left most). Defaults to 0.
        y_pos (int, optional): Y coordinate to place second image on the base image (0 is upper most). Defaults to 0.
        memory: (memory, optional): Memory to store the chat messages. DuckDBMemory will be used by default.
    """

    def __init__(
            self,
            base_image_path: str,
            x_pos: Optional[int] = 0,
            y_pos: Optional[int] = 0,
            memory: Optional[MemoryInterface] = None,
    ):
        if not base_image_path:
            raise ValueError("Please provide valid image path")

        file_from_path = Path(base_image_path)
        if not file_from_path.is_file():
            raise ValueError("File does not exist")

        if x_pos < 0 or y_pos < 0:
            raise ValueError("Position is out of boundary ")

        self._base_image_path = base_image_path
        self._x_pos = x_pos
        self._y_pos = y_pos
        self._memory = memory or DuckDBMemory()

    def _add_overlay_image(self, overlay_image_path: str) -> Image.Image:
        """
        Embed the second image onto the base image

        Args:
            overlay_image_path(str): The Path of second image

        Returns:
            Image.Image: The combined image with overlay.
        """
        if not overlay_image_path:
            raise ValueError("Please provide a valid image path")
        # Open the images
        with Image.open(self._base_image_path) as base_image, Image.open(overlay_image_path) as overlay_image:
            # Paste the second image onto the base image
            # And make a copy of the result, so it is accessible after "with" close
            base_image.paste(overlay_image, (self._x_pos, self._y_pos), overlay_image)
            result_image = base_image.copy()
        return result_image

    async def convert_async(self, *, prompt: str, input_type: PromptDataType = "image_path") -> ConverterResult:
        """
        Converter the base image to embed the second image onto it.

        Args:
            prompt (str): The filename of the second image
            input_type (PromptDataType): type of data, should be image_path

        Returns:
            ConverterResult: converted image with file path
        """
        if not self.input_supported(input_type):
            raise ValueError("Input type not supported")

        second_img_from_path = Path(prompt)
        if not second_img_from_path.is_file():
            raise ValueError("Overlay Image File does not exist")

        # Add overlay to the base image
        updated_img = self._add_overlay_image(prompt)

        # Create a new data serializer to save the images
        updated_image_serializer = data_serializer_factory(
            data_type="image_path",
            extension="png"  # you can change the file type as you want
        )

        # Save the result to the path generated by the serializer
        updated_img.save(updated_image_serializer.get_data_filename())

        return ConverterResult(output_text=str(updated_image_serializer.value), output_type="image_path")

    def input_supported(self, input_type: PromptDataType) -> bool:
        return input_type == "image_path"
