# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

"""
Chat service for managing conversations and message handling
"""

import uuid
from datetime import datetime
from typing import List, Optional, Dict, Any
import logging

from pyrit.backend.models.responses import ChatResponse, ConversationHistory, Message as DisplayMessage
from pyrit.backend.services.target_registry import TargetRegistry
from pyrit.models import Message, MessagePiece
from pyrit.prompt_normalizer import PromptNormalizer

logger = logging.getLogger(__name__)


class ChatService:
    """Service for handling chat operations"""

    def __init__(self):
        # In-memory storage for demo purposes
        # TODO: Integrate with PyRIT's memory system
        self.conversations: dict[str, ConversationHistory] = {}

    async def send_message(
        self, 
        original_value: str,
        converted_value: Optional[str] = None,
        conversation_id: Optional[str] = None, 
        target_id: Optional[str] = None,
        attachments: Optional[List[Dict[str, Any]]] = None,
        converter_identifiers: Optional[List[Dict[str, str]]] = None
    ) -> ChatResponse:
        """
        Send a message and get a response.
        Properly tracks original (pre-conversion) and converted (post-conversion) values.

        Args:
            original_value: The user's original message text before conversion
            converted_value: The message text after conversion (if converters were applied)
            conversation_id: Optional conversation ID to continue
            target_id: Optional target ID to use
            attachments: Optional file attachments
            converter_identifiers: Optional PyRIT converter identifiers from preview

        Returns:
            ChatResponse with the assistant's reply
        """
        # Create or get conversation
        if conversation_id is None:
            conversation_id = f"conv-{uuid.uuid4()}"

        if conversation_id not in self.conversations:
            self.conversations[conversation_id] = ConversationHistory(
                conversation_id=conversation_id,
                messages=[],
                target_id=target_id,
            )

        # Build message with converter_identifiers from preview
        # The identifiers were already generated by PromptNormalizer during preview
        from pyrit.models import SeedPrompt, SeedGroup
        
        # Use converter_identifiers from preview if provided
        final_converter_identifiers = converter_identifiers if converter_identifiers else []
        
        # Create MessagePiece with proper original and converted values
        # - original_value: text before any conversion
        # - converted_value: text after conversion (or same as original if no conversion)
        # Strip whitespace to avoid sending empty/newline-only text
        original_value = original_value.strip() if original_value else ""
        converted_value = converted_value.strip() if converted_value else None
        final_converted_value = converted_value if converted_value else original_value
        
        # Build list of message pieces (text + attachments)
        message_pieces = []
        
        # Add text message piece if present
        if original_value or final_converted_value:
            message_pieces.append(MessagePiece(
                role="user",
                original_value=original_value,
                converted_value=final_converted_value,
                conversation_id=conversation_id,
                converter_identifiers=final_converter_identifiers,
                original_value_data_type="text",
                converted_value_data_type="text",
            ))
        
        # Add attachment message pieces
        if attachments:
            for att in attachments:
                logger.info(f"Adding attachment to message: {att['name']} as {att['data_type']}")
                message_pieces.append(MessagePiece(
                    role="user",
                    conversation_id=conversation_id,
                    original_value=att['path'],
                    converted_value=att['path'],
                    original_value_data_type=att['data_type'],
                    converted_value_data_type=att['data_type'],
                ))
        
        user_message_pyrit = Message(message_pieces=message_pieces)
        
        # Use converted value for display
        value_to_send = final_converted_value
        
        # Add to our simple message list for display (show converted value)
        user_message = DisplayMessage(role="user", content=value_to_send)
        self.conversations[conversation_id].messages.append(user_message)
        
        # Get or create target instance
        if target_id:
            target = TargetRegistry.create_target_instance(target_id)
        else:
            target = TargetRegistry.get_default_attack_target()
        
        if not target:
            assistant_response = "Error: Target not configured. Please check your environment variables."
        else:
            # Use PromptNormalizer to send message and store in PyRIT memory
            normalizer = PromptNormalizer()
            try:
                # Send the properly constructed message with converter_identifiers to target
                # This will store it in PyRIT's memory system
                response = await normalizer.send_message_async(
                    message=user_message_pyrit,
                    target=target,
                )
                
                # Extract response text
                if response and response.message_pieces:
                    assistant_response = response.message_pieces[0].converted_value
                else:
                    assistant_response = "No response from target"
                    
            except ValueError as e:
                logger.exception(f"Configuration error: {e}")
                assistant_response = f"Configuration error: {str(e)}"
            except Exception as e:
                logger.exception(f"Error getting target response: {e}")
                # Include more details in error message
                import traceback
                error_details = traceback.format_exc()
                assistant_response = f"Error communicating with target: {str(e)}\n\nDetails:\n{error_details}"

        # Add assistant message
        assistant_message = DisplayMessage(role="assistant", content=assistant_response)
        self.conversations[conversation_id].messages.append(assistant_message)
        self.conversations[conversation_id].updated_at = datetime.utcnow()

        return ChatResponse(
            conversation_id=conversation_id,
            message=assistant_response,
            role="assistant",
            target_id=target_id,
        )

    async def get_conversations(self) -> List[ConversationHistory]:
        """Get all conversations"""
        return list(self.conversations.values())

    async def get_conversation(self, conversation_id: str) -> Optional[ConversationHistory]:
        """Get a specific conversation by ID"""
        return self.conversations.get(conversation_id)

    async def delete_conversation(self, conversation_id: str) -> bool:
        """Delete a conversation"""
        if conversation_id in self.conversations:
            del self.conversations[conversation_id]
            return True
        return False
